mod rpsish;
mod players;

use std::cmp::Ordering;

/* A GameState is a type for which there are two associated types: a View and an Action. The View
 * is a projection of the GameState into a subset that a particular player can see. An Action is
 * generated by the players and applied to the GameState to mutate it. */
trait GameState<'a> {
  type View;
  type Action;

  fn done(&self) -> bool;
  fn apply_action(&mut self, &Self::Action);
  fn to_view(&self, usize) -> Self::View;
}

/* A Player for a particular game can make moves on the game given a GameState::View. */
trait Player<'a> {
  type Game: GameState<'a>;

  /* Note: We have to explicitly annotate Self::Game as GameState<'a> in this signature because
   * https://github.com/rust-lang/rust/issues/38078 ... and we can't define a type alias for it
   * because https://github.com/rust-lang/rust/issues/29661 -- but trust me guys, Rust is good */
  fn pick_move(&self, usize, &<Self::Game as GameState<'a>>::View)
    -> <Self::Game as GameState<'a>>::Action;
}

fn main() {
  let mut game = rpsish::RpsishState {
    config: &rpsish::RpsishConfig {
      num_symbols: 5,
      num_rounds: 8,
      /* 0 beats 1 beats 2 beats 0 */
      payoffs: vec![
        vec![ 0, -6,  2,  8, -3],
        vec![ 6,  0, -1, -8,  5],
        vec![-2,  1,  0,  3,  0],
        vec![-8,  8, -3,  0,  7],
        vec![ 3, -5,  0, -7,  0],
      ],
    },
    player: 0,
    public_moves:  [Vec::new(), Vec::new()],
    private_moves: [Vec::new(), Vec::new()],
  };
  let players: [Box<Player<Game=rpsish::RpsishState>>; 2] = [
    //Box::new(players::ConstantPlayer { public: 0, private: 1 }),
    Box::new(players::SimpletonPlayer),
    Box::new(players::RandomPlayer),
  ];

  while !game.done() {
    let player = game.player;
    let view = game.to_view(player);
    let action = players[player].pick_move(player, &view);

    println!("=== Player {} ===", player);
    println!("State:  {}", game);
    println!("View:   {}", view);
    println!("Action: {:?}", action);
    println!();

    game.apply_action(&action);
  }

  println!("=== Results ===");
  println!("Player 0's public symbols:  {:?}", game.public_moves [0]);
  println!("Player 0's private symbols: {:?}", game.private_moves[0]);
  println!("Player 1's public symbols:  {:?}", game.public_moves [1]);
  println!("Player 1's private symbols: {:?}", game.private_moves[1]);

  let p0_score = game.calc_score(0);
  println!("Player 0's score: {}", p0_score);
  println!("Player 1's score: {}", game.calc_score(1));

  match p0_score.cmp(&0) {
    Ordering::Greater => println!("Player 0 wins!"),
    Ordering::Less    => println!("Player 1 wins!"),
    Ordering::Equal   => println!("It is a tie!"),
  }
}
